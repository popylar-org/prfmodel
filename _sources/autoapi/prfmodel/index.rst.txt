prfmodel
========

.. py:module:: prfmodel

.. autoapi-nested-parse::

   Documentation about prfmodel.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/prfmodel/adapter/index
   /autoapi/prfmodel/backend/index
   /autoapi/prfmodel/examples/index
   /autoapi/prfmodel/fitters/index
   /autoapi/prfmodel/models/index
   /autoapi/prfmodel/stimuli/index
   /autoapi/prfmodel/typing/index
   /autoapi/prfmodel/utils/index


Attributes
----------

.. autoapisummary::

   prfmodel.Tensor


Classes
-------

.. autoapisummary::

   prfmodel.PRFStimulus


Functions
---------

.. autoapisummary::

   prfmodel.convert_parameters_to_tensor


Package Contents
----------------

.. py:class:: PRFStimulus



   Container for a population receptive field stimulus design and its associated grid.

   :param design: The stimulus design array containing the stimulus value in one or more dimensions over different time frames.
                  The first axis is assumed to be time frames. Additional axes represent design dimensions.
   :type design: numpy.ndarray
   :param grid: The coordinate system of the design. The last axis is the number of design dimensions
                excluding the time frame dimension. The shape excluding the last axis must match the shape
                of the design excluding the first axis.
   :type grid: numpy.ndarray
   :param dimension_labels: Names of the grid dimensions (e.g., `["y", "x"]`). If given, the number of labels must match the last grid axis.
   :type dimension_labels: Sequence[str] or None, optional

   :raises GridDesignShapeError: If the design and grid dimensions do not match.
   :raises GridDimensionsError: If the number of dimensions of the grid except the last does not match the size of the last grid dimension.
   :raises DimensionLabelsError: If the number of dimensions does not match the grid's last dimension.

   .. rubric:: Notes

   The shapes of the design and grid must match according to `design.shape[1:] == grid.shape[:-1]`.
   That is, all design dimensions but the first must have the same size as the grid
   dimensions excluding the last grid dimension.

   .. rubric:: Examples

   Create a population receptive field stimulus on a 2D grid.

   >>> import numpy as np
   >>> num_frames, width, height = 10, 16, 16
   >>> design = np.ones((num_frames, width, height))
   >>> pixel_size = 0.05
   >>> x = (np.arange(width) - (width - 1) / 2) * pixel_size
   >>> y = (np.arange(height) - (height - 1) / 2) * pixel_size
   >>> xv, yv = np.meshgrid(x, y)
   >>> grid = np.stack((xv, yv), axis=-1)  # shape (height, width, 2)
   >>> grid = np.stack((xv, yv), axis=-1)  # shape (height, width, 2)
   >>> # The coordinates of the bottom-left corner:
   >>> grid[0, 0, :]
   array([-0.375, -0.375])
   >>> # The coordinates of the top-right corner:
   >>> grid[15, 15, :]
   array([0.375, 0.375])
   >>> stimulus = PRFStimulus(design=design, grid=grid, dimension_labels=["y", "x"])
   >>> print(stimulus)
   PRFStimulus(design=array[10, 16, 16], grid=array[16, 16, 2], dimension_labels=['y', 'x'])


   .. py:method:: create_2d_bar_stimulus(num_frames: int = 100, width: int = 128, height: int = 128, bar_width: int = 20, direction: str = 'horizontal', pixel_size: float = 0.05) -> PRFStimulus
      :classmethod:


      Create a population receptive field bar stimulus that moves across a 2D screen.

      The stimulus starts and ends moving just outside the screen.

      :param num_frames: Number of time frames in the stimulus.
      :type num_frames: int, optional
      :param width: Width of the stimulus grid (in pixels).
      :type width: int, optional
      :param height: Height of the stimulus grid (in pixels).
      :type height: int, optional
      :param bar_width: Width of the moving bar (in pixels).
      :type bar_width: int, optional
      :param direction: Direction in which the bar moves.
      :type direction: {"horizontal", "vertical"}, optional
      :param pixel_size: Size of a pixel in spatial units.
      :type pixel_size: float, optional

      :returns: A stimulus instance with the generated design and grid.
      :rtype: PRFStimulus

      :raises ValueError: If `direction` is not "horizontal" or "vertical".

      .. rubric:: Examples

      >>> stimulus = PRFStimulus.create_2d_bar_stimulus(num_frames=200)
      >>> print(stimulus)
      PRFStimulus(design=array[200, 128, 128], grid=array[128, 128, 2], dimension_labels=['y', 'x'])



   .. py:method:: __repr__() -> str

      Create a round-trippable string representation of the stimulus object.



   .. py:method:: __str__() -> str

      Create a human-readable string representation of the stimulus object.



.. py:type:: Tensor
   :canonical: BackendTensor


   Backend-specific tensor type.

.. py:function:: convert_parameters_to_tensor(parameters: pandas.DataFrame, dtype: str) -> prfmodel.typing.Tensor

   Convert model parameters in a dataframe into a tensor.

   :param parameters: Dataframe with columns containing different model parameters and rows containing
                      parameter values for different voxels.
   :type parameters: pandas.DataFrame

   :returns: Tensor with the first axis corresponding to voxels and the second axis corresponding to different parameters.
   :rtype: Tensor

   .. rubric:: Examples

   Single parameters:

   >>> import pandas as pd
   >>> params = pd.DataFrame({
   >>>     "param_1": [0.0, 1.0, 2.0],
   >>> })
   >>> x = convert_parameters_to_tensor(params)
   >>> print(x.shape)
   (3, 1)

   Multiple parameters:

   >>> params = pd.DataFrame({
   >>>     "param_1": [0.0, 1.0, 2.0],
   >>>     "param_2": [0.0, -1.0, -2.0],
   >>> })
   >>> x = covert_parameters_to_tensor(params)
   >>> print(x.shape)
   (3, 2)


